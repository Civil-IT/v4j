{"version":3,"file":"c398e2fa315d065f9b91d60b2ed9f70faf91aadf-8772517467b2994764bb.js","mappings":"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","sources":["webpack://vision-for-justice/./node_modules/scrollama/build/scrollama.js","webpack://vision-for-justice/./src/common/useScrollama.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.scrollama = factory();\n})(this, function () {\n  'use strict'; // DOM helper functions\n  // public\n\n  function selectAll(selector, parent) {\n    if (parent === void 0) parent = document;\n\n    if (typeof selector === 'string') {\n      return Array.from(parent.querySelectorAll(selector));\n    } else if (selector instanceof Element) {\n      return [selector];\n    } else if (selector instanceof NodeList) {\n      return Array.from(selector);\n    } else if (selector instanceof Array) {\n      return selector;\n    }\n\n    return [];\n  }\n\n  function getOffsetId(id) {\n    return \"scrollama__debug-offset--\" + id;\n  } // SETUP\n\n\n  function setupOffset(ref) {\n    var id = ref.id;\n    var offsetVal = ref.offsetVal;\n    var stepClass = ref.stepClass;\n    var el = document.createElement(\"div\");\n    el.id = getOffsetId(id);\n    el.className = \"scrollama__debug-offset\";\n    el.style.position = \"fixed\";\n    el.style.left = \"0\";\n    el.style.width = \"100%\";\n    el.style.height = \"0\";\n    el.style.borderTop = \"2px dashed black\";\n    el.style.zIndex = \"9999\";\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"\\\".\" + stepClass + \"\\\" trigger: <span>\" + offsetVal + \"</span>\";\n    p.style.fontSize = \"12px\";\n    p.style.fontFamily = \"monospace\";\n    p.style.color = \"black\";\n    p.style.margin = \"0\";\n    p.style.padding = \"6px\";\n    el.appendChild(p);\n    document.body.appendChild(el);\n  }\n\n  function setup(ref) {\n    var id = ref.id;\n    var offsetVal = ref.offsetVal;\n    var stepEl = ref.stepEl;\n    var stepClass = stepEl[0].className;\n    setupOffset({\n      id: id,\n      offsetVal: offsetVal,\n      stepClass: stepClass\n    });\n  } // UPDATE\n\n\n  function update(ref) {\n    var id = ref.id;\n    var offsetMargin = ref.offsetMargin;\n    var offsetVal = ref.offsetVal;\n    var format = ref.format;\n    var post = format === \"pixels\" ? \"px\" : \"\";\n    var idVal = getOffsetId(id);\n    var el = document.getElementById(idVal);\n    el.style.top = offsetMargin + \"px\";\n    el.querySelector(\"span\").innerText = \"\" + offsetVal + post;\n  }\n\n  function notifyStep(ref) {\n    var id = ref.id;\n    var index = ref.index;\n    var state = ref.state;\n    var prefix = \"scrollama__debug-step--\" + id + \"-\" + index;\n    var elA = document.getElementById(prefix + \"_above\");\n    var elB = document.getElementById(prefix + \"_below\");\n    var display = state === \"enter\" ? \"block\" : \"none\";\n\n    if (elA) {\n      elA.style.display = display;\n    }\n\n    if (elB) {\n      elB.style.display = display;\n    }\n  }\n\n  function scrollama() {\n    var OBSERVER_NAMES = [\"stepAbove\", \"stepBelow\", \"stepProgress\", \"viewportAbove\", \"viewportBelow\"];\n    var cb = {};\n    var io = {};\n    var id = null;\n    var stepEl = [];\n    var stepOffsetHeight = [];\n    var stepOffsetTop = [];\n    var stepStates = [];\n    var offsetVal = 0;\n    var offsetMargin = 0;\n    var viewH = 0;\n    var pageH = 0;\n    var previousYOffset = 0;\n    var progressThreshold = 0;\n    var isReady = false;\n    var isEnabled = false;\n    var isDebug = false;\n    var progressMode = false;\n    var preserveOrder = false;\n    var triggerOnce = false;\n    var direction = \"down\";\n    var format = \"percent\";\n    var exclude = [];\n    /* HELPERS */\n\n    function err(msg) {\n      console.error(\"scrollama error: \" + msg);\n    }\n\n    function reset() {\n      cb = {\n        stepEnter: function stepEnter() {},\n        stepExit: function stepExit() {},\n        stepProgress: function stepProgress() {}\n      };\n      io = {};\n    }\n\n    function generateInstanceID() {\n      var a = \"abcdefghijklmnopqrstuv\";\n      var l = a.length;\n      var t = Date.now();\n      var r = [0, 0, 0].map(function (d) {\n        return a[Math.floor(Math.random() * l)];\n      }).join(\"\");\n      return \"\" + r + t;\n    }\n\n    function getOffsetTop(el) {\n      var ref = el.getBoundingClientRect();\n      var top = ref.top;\n      var scrollTop = window.pageYOffset;\n      var clientTop = document.body.clientTop || 0;\n      return top + scrollTop - clientTop;\n    }\n\n    function getPageHeight() {\n      var body = document.body;\n      var html = document.documentElement;\n      return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n    }\n\n    function getIndex(element) {\n      return +element.getAttribute(\"data-scrollama-index\");\n    }\n\n    function updateDirection() {\n      if (window.pageYOffset > previousYOffset) {\n        direction = \"down\";\n      } else if (window.pageYOffset < previousYOffset) {\n        direction = \"up\";\n      }\n\n      previousYOffset = window.pageYOffset;\n    }\n\n    function disconnectObserver(name) {\n      if (io[name]) {\n        io[name].forEach(function (d) {\n          return d.disconnect();\n        });\n      }\n    }\n\n    function handleResize() {\n      viewH = window.innerHeight;\n      pageH = getPageHeight();\n      var mult = format === \"pixels\" ? 1 : viewH;\n      offsetMargin = offsetVal * mult;\n\n      if (isReady) {\n        stepOffsetHeight = stepEl.map(function (el) {\n          return el.getBoundingClientRect().height;\n        });\n        stepOffsetTop = stepEl.map(getOffsetTop);\n\n        if (isEnabled) {\n          updateIO();\n        }\n      }\n\n      if (isDebug) {\n        update({\n          id: id,\n          offsetMargin: offsetMargin,\n          offsetVal: offsetVal,\n          format: format\n        });\n      }\n    }\n\n    function handleEnable(enable) {\n      if (enable && !isEnabled) {\n        // enable a disabled scroller\n        if (isReady) {\n          // enable a ready scroller\n          updateIO();\n        } else {\n          // can't enable an unready scroller\n          err(\"scrollama error: enable() called before scroller was ready\");\n          isEnabled = false;\n          return; // all is not well, don't set the requested state\n        }\n      }\n\n      if (!enable && isEnabled) {\n        // disable an enabled scroller\n        OBSERVER_NAMES.forEach(disconnectObserver);\n      }\n\n      isEnabled = enable; // all is well, set requested state\n    }\n\n    function createThreshold(height) {\n      var count = Math.ceil(height / progressThreshold);\n      var t = [];\n      var ratio = 1 / count;\n\n      for (var i = 0; i < count; i += 1) {\n        t.push(i * ratio);\n      }\n\n      return t;\n    }\n    /* NOTIFY CALLBACKS */\n\n\n    function notifyStepProgress(element, progress) {\n      var index = getIndex(element);\n\n      if (progress !== undefined) {\n        stepStates[index].progress = progress;\n      }\n\n      var resp = {\n        element: element,\n        index: index,\n        progress: stepStates[index].progress\n      };\n\n      if (stepStates[index].state === \"enter\") {\n        cb.stepProgress(resp);\n      }\n    }\n\n    function notifyOthers(index, location) {\n      if (location === \"above\") {\n        // check if steps above/below were skipped and should be notified first\n        for (var i = 0; i < index; i += 1) {\n          var ss = stepStates[i];\n\n          if (ss.state !== \"enter\" && ss.direction !== \"down\") {\n            notifyStepEnter(stepEl[i], \"down\", false);\n            notifyStepExit(stepEl[i], \"down\");\n          } else if (ss.state === \"enter\") {\n            notifyStepExit(stepEl[i], \"down\");\n          } // else if (ss.direction === 'up') {\n          //   notifyStepEnter(stepEl[i], 'down', false);\n          //   notifyStepExit(stepEl[i], 'down');\n          // }\n\n        }\n      } else if (location === \"below\") {\n        for (var i$1 = stepStates.length - 1; i$1 > index; i$1 -= 1) {\n          var ss$1 = stepStates[i$1];\n\n          if (ss$1.state === \"enter\") {\n            notifyStepExit(stepEl[i$1], \"up\");\n          }\n\n          if (ss$1.direction === \"down\") {\n            notifyStepEnter(stepEl[i$1], \"up\", false);\n            notifyStepExit(stepEl[i$1], \"up\");\n          }\n        }\n      }\n    }\n\n    function notifyStepEnter(element, dir, check) {\n      if (check === void 0) check = true;\n      var index = getIndex(element);\n      var resp = {\n        element: element,\n        index: index,\n        direction: dir\n      }; // store most recent trigger\n\n      stepStates[index].direction = dir;\n      stepStates[index].state = \"enter\";\n\n      if (preserveOrder && check && dir === \"down\") {\n        notifyOthers(index, \"above\");\n      }\n\n      if (preserveOrder && check && dir === \"up\") {\n        notifyOthers(index, \"below\");\n      }\n\n      if (cb.stepEnter && !exclude[index]) {\n        cb.stepEnter(resp, stepStates);\n\n        if (isDebug) {\n          notifyStep({\n            id: id,\n            index: index,\n            state: \"enter\"\n          });\n        }\n\n        if (triggerOnce) {\n          exclude[index] = true;\n        }\n      }\n\n      if (progressMode) {\n        notifyStepProgress(element);\n      }\n    }\n\n    function notifyStepExit(element, dir) {\n      var index = getIndex(element);\n      var resp = {\n        element: element,\n        index: index,\n        direction: dir\n      };\n\n      if (progressMode) {\n        if (dir === \"down\" && stepStates[index].progress < 1) {\n          notifyStepProgress(element, 1);\n        } else if (dir === \"up\" && stepStates[index].progress > 0) {\n          notifyStepProgress(element, 0);\n        }\n      } // store most recent trigger\n\n\n      stepStates[index].direction = dir;\n      stepStates[index].state = \"exit\";\n      cb.stepExit(resp, stepStates);\n\n      if (isDebug) {\n        notifyStep({\n          id: id,\n          index: index,\n          state: \"exit\"\n        });\n      }\n    }\n    /* OBSERVER - INTERSECT HANDLING */\n    // this is good for entering while scrolling down + leaving while scrolling up\n\n\n    function intersectStepAbove(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target; // bottom = bottom edge of element from top of viewport\n      // bottomAdjusted = bottom edge of element from trigger\n\n      var top = boundingClientRect.top;\n      var bottom = boundingClientRect.bottom;\n      var topAdjusted = top - offsetMargin;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index]; // entering above is only when topAdjusted is negative\n      // and bottomAdjusted is positive\n\n      if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === \"down\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, direction);\n      } // exiting from above is when topAdjusted is positive and not intersecting\n\n\n      if (!isIntersecting && topAdjusted > 0 && direction === \"up\" && ss.state === \"enter\") {\n        notifyStepExit(target, direction);\n      }\n    } // this is good for entering while scrolling up + leaving while scrolling down\n\n\n    function intersectStepBelow(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target; // bottom = bottom edge of element from top of viewport\n      // bottomAdjusted = bottom edge of element from trigger\n\n      var top = boundingClientRect.top;\n      var bottom = boundingClientRect.bottom;\n      var topAdjusted = top - offsetMargin;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index]; // entering below is only when bottomAdjusted is positive\n      // and topAdjusted is negative\n\n      if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === \"up\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, direction);\n      } // exiting from above is when bottomAdjusted is negative and not intersecting\n\n\n      if (!isIntersecting && bottomAdjusted < 0 && direction === \"down\" && ss.state === \"enter\") {\n        notifyStepExit(target, direction);\n      }\n    }\n    /*\n    if there is a scroll event where a step never intersects (therefore\n    skipping an enter/exit trigger), use this fallback to detect if it is\n    in view\n    */\n\n\n    function intersectViewportAbove(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      if (isIntersecting && direction === \"down\" && ss.direction !== \"down\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, \"down\");\n        notifyStepExit(target, \"down\");\n      }\n    }\n\n    function intersectViewportBelow(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      if (isIntersecting && direction === \"up\" && ss.direction === \"down\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, \"up\");\n        notifyStepExit(target, \"up\");\n      }\n    }\n\n    function intersectStepProgress(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var intersectionRatio = entry.intersectionRatio;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n      var bottom = boundingClientRect.bottom;\n      var bottomAdjusted = bottom - offsetMargin;\n\n      if (isIntersecting && bottomAdjusted >= 0) {\n        notifyStepProgress(target, +intersectionRatio);\n      }\n    }\n    /*  OBSERVER - CREATION */\n    // jump into viewport\n\n\n    function updateViewportAboveIO() {\n      io.viewportAbove = stepEl.map(function (el, i) {\n        var marginTop = pageH - stepOffsetTop[i];\n        var marginBottom = offsetMargin - viewH - stepOffsetHeight[i];\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectViewportAbove, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    function updateViewportBelowIO() {\n      io.viewportBelow = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin - stepOffsetHeight[i];\n        var marginBottom = offsetMargin - viewH + stepOffsetHeight[i] + pageH;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectViewportBelow, options);\n        obs.observe(el);\n        return obs;\n      });\n    } // look above for intersection\n\n\n    function updateStepAboveIO() {\n      io.stepAbove = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin + stepOffsetHeight[i];\n        var marginBottom = offsetMargin - viewH;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectStepAbove, options);\n        obs.observe(el);\n        return obs;\n      });\n    } // look below for intersection\n\n\n    function updateStepBelowIO() {\n      io.stepBelow = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin;\n        var marginBottom = offsetMargin - viewH + stepOffsetHeight[i];\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectStepBelow, options);\n        obs.observe(el);\n        return obs;\n      });\n    } // progress progress tracker\n\n\n    function updateStepProgressIO() {\n      io.stepProgress = stepEl.map(function (el, i) {\n        var marginTop = stepOffsetHeight[i] - offsetMargin;\n        var marginBottom = -viewH + offsetMargin;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var threshold = createThreshold(stepOffsetHeight[i]);\n        var options = {\n          rootMargin: rootMargin,\n          threshold: threshold\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectStepProgress, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    function updateIO() {\n      OBSERVER_NAMES.forEach(disconnectObserver);\n      updateViewportAboveIO();\n      updateViewportBelowIO();\n      updateStepAboveIO();\n      updateStepBelowIO();\n\n      if (progressMode) {\n        updateStepProgressIO();\n      }\n    }\n    /* SETUP FUNCTIONS */\n\n\n    function indexSteps() {\n      stepEl.forEach(function (el, i) {\n        return el.setAttribute(\"data-scrollama-index\", i);\n      });\n    }\n\n    function setupStates() {\n      stepStates = stepEl.map(function () {\n        return {\n          direction: null,\n          state: null,\n          progress: 0\n        };\n      });\n    }\n\n    function addDebug() {\n      if (isDebug) {\n        setup({\n          id: id,\n          stepEl: stepEl,\n          offsetVal: offsetVal\n        });\n      }\n    }\n\n    function isYScrollable(element) {\n      var style = window.getComputedStyle(element);\n      return (style.overflowY === \"scroll\" || style.overflowY === \"auto\") && element.scrollHeight > element.clientHeight;\n    } // recursively search the DOM for a parent container with overflowY: scroll and fixed height\n    // ends at document\n\n\n    function anyScrollableParent(element) {\n      if (element && element.nodeType === 1) {\n        // check dom elements only, stop at document\n        // if a scrollable element is found return the element\n        // if not continue to next parent\n        return isYScrollable(element) ? element : anyScrollableParent(element.parentNode);\n      }\n\n      return false; // didn't find a scrollable parent\n    }\n\n    var S = {};\n\n    S.setup = function (ref) {\n      var step = ref.step;\n      var parent = ref.parent;\n      var offset = ref.offset;\n      if (offset === void 0) offset = 0.5;\n      var progress = ref.progress;\n      if (progress === void 0) progress = false;\n      var threshold = ref.threshold;\n      if (threshold === void 0) threshold = 4;\n      var debug = ref.debug;\n      if (debug === void 0) debug = false;\n      var order = ref.order;\n      if (order === void 0) order = true;\n      var once = ref.once;\n      if (once === void 0) once = false;\n      reset(); // create id unique to this scrollama instance\n\n      id = generateInstanceID();\n      stepEl = selectAll(step, parent);\n\n      if (!stepEl.length) {\n        err(\"no step elements\");\n        return S;\n      } // ensure that no step has a scrollable parent element in the dom tree\n      // check current step for scrollable parent\n      // assume no scrollable parents to start\n\n\n      var scrollableParent = stepEl.reduce(function (foundScrollable, s) {\n        return foundScrollable || anyScrollableParent(s.parentNode);\n      }, false);\n\n      if (scrollableParent) {\n        console.error(\"scrollama error: step elements cannot be children of a scrollable element. Remove any css on the parent element with overflow: scroll; or overflow: auto; on elements with fixed height.\", scrollableParent);\n      } // options\n\n\n      isDebug = debug;\n      progressMode = progress;\n      preserveOrder = order;\n      triggerOnce = once;\n      S.offsetTrigger(offset);\n      progressThreshold = Math.max(1, +threshold);\n      isReady = true; // customize\n\n      addDebug();\n      indexSteps();\n      setupStates();\n      handleResize();\n      S.enable();\n      return S;\n    };\n\n    S.resize = function () {\n      handleResize();\n      return S;\n    };\n\n    S.enable = function () {\n      handleEnable(true);\n      return S;\n    };\n\n    S.disable = function () {\n      handleEnable(false);\n      return S;\n    };\n\n    S.destroy = function () {\n      handleEnable(false);\n      reset();\n    };\n\n    S.offsetTrigger = function (x) {\n      if (x === null) {\n        return offsetVal;\n      }\n\n      if (typeof x === \"number\") {\n        format = \"percent\";\n\n        if (x > 1) {\n          err(\"offset value is greater than 1. Fallback to 1.\");\n        }\n\n        if (x < 0) {\n          err(\"offset value is lower than 0. Fallback to 0.\");\n        }\n\n        offsetVal = Math.min(Math.max(0, x), 1);\n      } else if (typeof x === \"string\" && x.indexOf(\"px\") > 0) {\n        var v = +x.replace(\"px\", \"\");\n\n        if (!isNaN(v)) {\n          format = \"pixels\";\n          offsetVal = v;\n        } else {\n          err(\"offset value must be in 'px' format. Fallback to 0.5.\");\n          offsetVal = 0.5;\n        }\n      } else {\n        err(\"offset value does not include 'px'. Fallback to 0.5.\");\n        offsetVal = 0.5;\n      }\n\n      return S;\n    };\n\n    S.onStepEnter = function (f) {\n      if (typeof f === \"function\") {\n        cb.stepEnter = f;\n      } else {\n        err(\"onStepEnter requires a function\");\n      }\n\n      return S;\n    };\n\n    S.onStepExit = function (f) {\n      if (typeof f === \"function\") {\n        cb.stepExit = f;\n      } else {\n        err(\"onStepExit requires a function\");\n      }\n\n      return S;\n    };\n\n    S.onStepProgress = function (f) {\n      if (typeof f === \"function\") {\n        cb.stepProgress = f;\n      } else {\n        err(\"onStepProgress requires a function\");\n      }\n\n      return S;\n    };\n\n    return S;\n  }\n\n  return scrollama;\n});","import scrollama from \"scrollama\";\r\nimport { useEffect } from \"react\";\r\n\r\n/**\r\n * useScrollama: an easier usage of scrollama as a react hook\r\n *\r\n *    useScrollama(titleRef, {\r\n *      offset: 0.75,\r\n *      // debug: true,\r\n *      onStepProgress: (response) => {\r\n *        const { progress } = response;\r\n *        setOverlayLineHeight(getLineHeight(progress));\r\n *      },\r\n *    });\r\n *\r\n * @param  {Object} ref     a react ref of the element you want to track\r\n * @param  {Object} options options from scrollama plus step functions and offsetTrigger\r\n *   see https://github.com/russellgoldenberg/scrollama#scrollamasetupoptions\r\n */\r\nexport default function useScrollama(ref, options) {\r\n  useEffect(() => {\r\n    if (ref.current) {\r\n      const {\r\n        onStepEnter = () => {},\r\n        onStepExit = () => {},\r\n        onStepProgress = () => {},\r\n        offsetTrigger = null,\r\n      } = options;\r\n\r\n      const scroller = scrollama();\r\n\r\n      scroller\r\n        .setup({\r\n          step: ref.current,\r\n          progress: options.onStepProgress ? true : false,\r\n          ...options,\r\n        })\r\n        .onStepEnter(onStepEnter)\r\n        .onStepExit(onStepExit)\r\n        .onStepProgress(onStepProgress)\r\n        .offsetTrigger(offsetTrigger);\r\n\r\n      window.addEventListener(\"resize\", scroller.resize);\r\n      window.addEventListener(\"load\", scroller.resize); // after images load, recalculate\r\n\r\n      return () => {\r\n        window.removeEventListener(\"resize\", scroller.resize);\r\n        window.removeEventListener(\"load\", scroller.resize);\r\n      };\r\n    }\r\n    // we only want to set this up once!\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n}\r\n"],"names":["module","exports","selectAll","selector","parent","document","Array","from","querySelectorAll","Element","NodeList","getOffsetId","id","setupOffset","ref","offsetVal","stepClass","el","createElement","className","style","position","left","width","height","borderTop","zIndex","p","innerHTML","fontSize","fontFamily","color","margin","padding","appendChild","body","setup","stepEl","update","offsetMargin","post","format","idVal","getElementById","top","querySelector","innerText","notifyStep","index","state","prefix","elA","elB","display","scrollama","OBSERVER_NAMES","cb","io","stepOffsetHeight","stepOffsetTop","stepStates","viewH","pageH","previousYOffset","progressThreshold","isReady","isEnabled","isDebug","progressMode","preserveOrder","triggerOnce","direction","exclude","err","msg","console","error","reset","stepEnter","stepExit","stepProgress","generateInstanceID","a","l","length","t","Date","now","map","d","Math","floor","random","join","getOffsetTop","getBoundingClientRect","window","pageYOffset","clientTop","getPageHeight","html","documentElement","max","scrollHeight","offsetHeight","clientHeight","getIndex","element","getAttribute","updateDirection","disconnectObserver","name","forEach","disconnect","handleResize","innerHeight","updateIO","handleEnable","enable","createThreshold","count","ceil","ratio","i","push","notifyStepProgress","progress","undefined","resp","notifyOthers","location","ss","notifyStepEnter","notifyStepExit","i$1","ss$1","dir","check","intersectStepAbove","entry","isIntersecting","boundingClientRect","target","bottom","topAdjusted","bottomAdjusted","intersectStepBelow","intersectViewportAbove","intersectViewportBelow","intersectStepProgress","intersectionRatio","updateViewportAboveIO","viewportAbove","marginTop","marginBottom","obs","IntersectionObserver","rootMargin","observe","updateViewportBelowIO","viewportBelow","updateStepAboveIO","stepAbove","updateStepBelowIO","stepBelow","updateStepProgressIO","threshold","indexSteps","setAttribute","setupStates","addDebug","isYScrollable","getComputedStyle","overflowY","anyScrollableParent","nodeType","parentNode","S","step","offset","debug","order","once","scrollableParent","reduce","foundScrollable","s","offsetTrigger","x","min","indexOf","v","replace","isNaN","f","factory","useScrollama","options","useEffect","current","onStepEnter","onStepExit","onStepProgress","scroller","addEventListener","resize","removeEventListener"],"sourceRoot":""}