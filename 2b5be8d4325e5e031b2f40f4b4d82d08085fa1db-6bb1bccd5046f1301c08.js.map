{"version":3,"file":"2b5be8d4325e5e031b2f40f4b4d82d08085fa1db-6bb1bccd5046f1301c08.js","mappings":"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","sources":["webpack://vision-for-justice/./node_modules/ramda/es/identity.js","webpack://vision-for-justice/./node_modules/swiper/esm/components/mousewheel/mousewheel.js","webpack://vision-for-justice/./src/common/extractInfoBlock.js","webpack://vision-for-justice/./src/components/OutlineTextPromo/OutlineTextPromo.jsx"],"sourcesContent":["import _curry1 from \"./internal/_curry1.js\";\nimport _identity from \"./internal/_identity.js\";\n/**\n * A function that does nothing but return the parameter supplied to it. Good\n * as a default or placeholder function.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig a -> a\n * @param {*} x The value to return.\n * @return {*} The input value, `x`.\n * @example\n *\n *      R.identity(1); //=> 1\n *\n *      const obj = {};\n *      R.identity(obj) === obj; //=> true\n * @symb R.identity(a) = a\n */\n\nvar identity = /*#__PURE__*/_curry1(_identity);\n\nexport default identity;","/* eslint-disable consistent-return */\nimport { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../utils/dom';\nimport { now, nextTick, bindModuleMethods } from '../../utils/utils';\n\nfunction isEventSupported() {\n  var document = getDocument();\n  var eventName = 'onwheel';\n  var isSupported = (eventName in document);\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nvar Mousewheel = {\n  lastScrollTime: now(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event: function event() {\n    var window = getWindow();\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  },\n  handleMouseEnter: function handleMouseEnter() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave: function handleMouseLeave() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  },\n  handle: function handle(event) {\n    var e = event;\n    var disableParentSwiper = true;\n    var swiper = this;\n    if (!swiper.enabled) return;\n    var params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    var delta = 0;\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    var data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta; // Get the scroll positions\n\n    var positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      var newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      var _newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n\n        var position = swiper.getTranslate() + delta * params.sensitivity;\n        var wasBeginning = swiper.isBeginning;\n        var wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n          if (_recentWheelEvents.length >= 15) {\n            _recentWheelEvents.shift(); // only store the last N events\n\n          }\n\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\n\n          var firstEvent = _recentWheelEvents[0];\n\n          _recentWheelEvents.push(_newEvent);\n\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            _recentWheelEvents.splice(0);\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n            _recentWheelEvents.splice(0);\n\n            swiper.mousewheel.timeout = nextTick(function () {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = nextTick(function () {\n              var snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n              _recentWheelEvents.splice(0);\n\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  },\n  animateSlider: function animateSlider(newEvent) {\n    var swiper = this;\n    var window = getWindow();\n\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  },\n  releaseScroll: function releaseScroll(newEvent) {\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n};\nexport default {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    bindModuleMethods(swiper, {\n      mousewheel: {\n        enabled: false,\n        lastScrollTime: now(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n        enable: Mousewheel.enable,\n        disable: Mousewheel.disable,\n        handle: Mousewheel.handle,\n        handleMouseEnter: Mousewheel.handleMouseEnter,\n        handleMouseLeave: Mousewheel.handleMouseLeave,\n        animateSlider: Mousewheel.animateSlider,\n        releaseScroll: Mousewheel.releaseScroll\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    }\n  }\n};","import * as R from \"ramda\";\r\n\r\nimport extractLink, { linkFields } from \"./extractLink.js\";\r\nimport extractTag, { tagFields } from \"./extractTag.js\";\r\nimport { node, shape, string } from \"prop-types\";\r\n\r\nimport extractImage from \"./extractImage.jsx\";\r\nimport { renderRichText } from \"gatsby-source-contentful/rich-text\";\r\n\r\nexport default R.compose(\r\n  R.applySpec({\r\n    title: R.prop(\"title\"),\r\n    sectionTitle: R.prop(\"sectionTitle\"),\r\n    text: R.compose(R.unless(R.isNil, renderRichText), R.prop(\"description\")),\r\n    image: R.ifElse(\r\n      (data) => data === null,\r\n      //return undefined so components render nothing\r\n      () => undefined,\r\n      R.compose(extractImage, R.prop(\"image\")),\r\n    ),\r\n    link: R.ifElse(\r\n      (data) => data === null,\r\n      //return undefined so components render nothing\r\n      () => undefined,\r\n      R.compose(extractLink, R.prop(\"link\")),\r\n    ),\r\n    tag: R.compose(R.unless(R.isNil, extractTag), R.prop(\"tag\")),\r\n  }),\r\n  R.defaultTo({}),\r\n);\r\n\r\nexport const infoBlockFields = {\r\n  title: string,\r\n  sectionTitle: string,\r\n  text: string,\r\n  image: node,\r\n  link: shape(linkFields),\r\n  tag: shape(tagFields),\r\n};\r\n","import \"./outline-text-promo.scss\";\r\n\r\nimport { bool, string } from \"prop-types\";\r\nimport { useRef, useState } from \"react\";\r\n\r\nimport cx from \"classnames\";\r\nimport useAOS from \"../../common/useAOS.js\";\r\nimport useMatchMedia from \"../../common/useMatchMedia.js\";\r\nimport useScrollama from \"../../common/useScrollama.js\";\r\n\r\nconst propTypes = {\r\n  textLine1: string.isRequired,\r\n  textLine2: string,\r\n  dark: bool,\r\n};\r\n\r\nconst OutlineText = (props) => {\r\n  const { textLine1, textLine2, dark } = props;\r\n\r\n  useAOS();\r\n\r\n  const promoRef = useRef();\r\n\r\n  const isNotMobile = useMatchMedia(\"(min-width: 680px)\"); // matches $bp-small-min in _breakpoints.scss\r\n\r\n  const [shouldAnimate, setShouldAnimate] = useState(false);\r\n\r\n  useScrollama(promoRef, {\r\n    offset: 0.7,\r\n    // debug: true,\r\n    onStepEnter: (response) => setShouldAnimate(true),\r\n    once: true,\r\n  });\r\n\r\n  return (\r\n    <section ref={promoRef} className=\"outline-text-promo\">\r\n      <svg width=\"inherit\" height=\"inherit\" xmlns=\"http://www.w3.org/2000/svg\">\r\n        <defs>\r\n          <linearGradient id=\"gradient\" x1=\"0\" x2=\"1\">\r\n            <stop stopColor=\"#7300e7\" offset=\"0\" />\r\n            <stop stopColor=\"#f7453d\" offset=\"1\" />\r\n          </linearGradient>\r\n        </defs>\r\n        {shouldAnimate && (\r\n          <g>\r\n            <text\r\n              data-aos=\"slide-left\"\r\n              data-aos-duration=\"3000\"\r\n              id=\"text\"\r\n              className={cx(\"outline-text-promo__line1 outline-text\", {\r\n                \"outline-text--dark\": dark,\r\n              })}\r\n              y=\".8em\"\r\n              strokeWidth=\"2\"\r\n              stroke=\"url(#gradient)\"\r\n              fill=\"transparent\"\r\n            >\r\n              {textLine1}\r\n            </text>\r\n            {textLine2 && (\r\n              <text\r\n                data-aos=\"slide-right\"\r\n                data-aos-delay=\"300\"\r\n                data-aos-duration=\"3000\"\r\n                id=\"text\"\r\n                className={cx(\"outline-text-promo__line2 outline-text\", {\r\n                  \"outline-text--dark\": dark,\r\n                })}\r\n                y=\"1.8em\"\r\n                x={isNotMobile ? 100 : 40}\r\n                strokeWidth=\"2\"\r\n                stroke=\"url(#gradient)\"\r\n                fill=\"transparent\"\r\n              >\r\n                {textLine2}\r\n              </text>\r\n            )}\r\n          </g>\r\n        )}\r\n      </svg>\r\n    </section>\r\n  );\r\n};\r\n\r\nOutlineText.propTypes = propTypes;\r\nexport default OutlineText;\r\n"],"names":["identity","Mousewheel","lastScrollTime","lastEventBeforeSnap","undefined","recentWheelEvents","event","navigator","userAgent","indexOf","document","eventName","isSupported","element","createElement","setAttribute","implementation","hasFeature","isEventSupported","normalize","e","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","this","enabled","mouseEntered","handleMouseLeave","handle","swiper","params","mousewheel","cssMode","preventDefault","target","$el","eventsTarget","contains","releaseOnEdges","originalEvent","delta","rtlFactor","rtlTranslate","data","forceToAxis","isHorizontal","Math","abs","invert","positions","getTranslate","sensitivity","minTranslate","maxTranslate","loop","nested","stopPropagation","freeMode","_newEvent","time","direction","sign","ignoreWheelEvents","loopFix","position","wasBeginning","isBeginning","wasEnd","isEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","freeModeSticky","clearTimeout","timeout","_recentWheelEvents","length","shift","_prevEvent","firstEvent","push","splice","snapToThreshold","slideToClosest","speed","emit","autoplay","autoplayDisableOnInteraction","stop","newEvent","raw","prevEvent","animateSlider","releaseScroll","returnValue","window","thresholdDelta","thresholdTime","animating","slideNext","slidePrev","Date","getTime","enable","wrapperEl","removeEventListener","on","disable","addEventListener","off","name","create","init","destroy","R","title","sectionTitle","text","renderRichText","image","extractImage","link","extractLink","tag","extractTag","string","node","shape","linkFields","tagFields","propTypes","textLine1","textLine2","dark","bool","OutlineText","props","useAOS","promoRef","useRef","isNotMobile","useMatchMedia","useState","shouldAnimate","setShouldAnimate","useScrollama","offset","onStepEnter","response","once","ref","className","width","height","xmlns","id","x1","x2","stopColor","cx","y","strokeWidth","stroke","fill","x"],"sourceRoot":""}